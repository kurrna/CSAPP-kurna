# 数据表示

## 浮点数

#### 浮点数的表示

- 浮点数的表示：$(-1)^s M 2^E$

- 其中s为符号位决定正负；M通常为一个$[1.0, 2.0)$的小数；E是次方数

- 单精度：32位

  | s    | exp  | frac |
  | ---- | ---- | ---- |
  | 1    | 8    | 23   |

- 双精度：64位

  |      | s    | exp  | frac |
  | ---- | ---- | ---- | ---- |
  | 位数 | 1    | 11   | 52   |

- 规范化值：在$exp\neq 000\ldots 0, exp \neq 111\ldots 1$时

  - $M = 1.xxx\ldots x_2$，其中xxx的部分即为frac的编码部分
  - $E=Exp-Bias$
    - Exp：是exp编码区域的无符号数值（最大为$111\ldots 0$）
    - Bias：值为$2^{k-1}-1$的偏移量，其中k为exp编码的位数
      - 单精度：$\;127\;(Exp: 1\dots 254, E: -126\ldots 127)$
      - 双精度：$1023(Exp: 1\ldots 2046, E: -1022\ldots 1023)$

- 非规范化值：当$exp=000\ldots 0$时，

  - $M=0.xxx\ldots x_2$
  - $E=1-Bias$
  - 当frac=0时表示0（因为有符号位，实际上为正0和负0）

- 特殊值：当$exp=111\ldots 1$，用来表示一些特殊值

  | frac   | $=000\ldots 0$                         | $\neq 000\ldots 0$          |
  | ------ | -------------------------------------- | --------------------------- |
  | 表示值 | $\infin$（根据符号位有正无穷与负无穷） | NaN（用来表示没办法确定的值 |

- 在$exp=000\ldots 0$时（即非规范化情况时）间距一致，数值接近0
- 规范化情况下因为exp不同，相邻数字间的间隔不同

#### 舍入

对于浮点数的加法和乘法来说，先计算出准确值，然后转换到合适的精度

- 在二进制中，以最后一位为偶数来进行四舍五入（五可能向上也可能向下）

#### 浮点数加法

$(-1)^{s_1}M_12^{E_1}+(-1)^{s_2}M_22^{E_2}$

假设$E_1>E_2$，结果是$(-1)^sM2^E$，其中$s=s_1∧s_2,M=M_1+M_2,E=E_1$

- 如果M大于等于2，那么将M右移并增加E的值
- 如果M小于1，把M左移k位，E减少k
- 如果E超出了可以表示的范围，溢出
- 把M舍入到frac的精度

**基本性质**

- 相加可能产生$\infin$或者$NaN$
- 满足交换律，不满足结合律（舍入会造成精度损失）

#### 浮点数乘法

$(-1)^{s_1}M_12^{E_1}*(-1)^{s_2}M_22^{E_2}$

假设$E_1>E_2$，结果是$(-1)^sM2^E$，其中$s=s_1∧s_2,M=M_1*M_2,E=E_1+E_2$

- 如果M大于等于2，那么把M右移，并增加E的值
- 如果E超出了表示的范围，溢出
- 把M舍入到frac的精度

**基本性质**

- 相乘可能产生$\infin$或者$NaN$
- 满足交换律，不满足结合律（舍入会造成精度损失）
- 不满足分配律

## 数据在内存中的表示

分为大端（Big Endian）与小端（Little Endian）两种表示

假如变量 `x` 是 4 字节，值为 `0x01234567`。用 `&x` 索引的地址是 `0x100`，那么大端和小端的表示形式是

|      | 0x100 | 0x101 | 0x102 | 0x103 |
| ---- | ----- | ----- | ----- | ----- |
| 大端 | 01    | 23    | 45    | 67    |
| 小端 | 67    | 45    | 23    | 01    |

在计算机网络中数据遵守“网络字节序”（大端），在（主流）处理器内部处理时遵守“主机字节序”（小端），在发送数据时调用`htons()/htonl()`(Host to Network Short/Long)函数将小端转为大端，接收数据时调用`ntohs()/ntohl()`(Network to Host Short/Long)函数将大端转为小端